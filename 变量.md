[TOC]

# 命名规范

* **常量**：下划线分割的全大写字母，例如：`MAX_POINTS`

# 变量

## let

当以如下方式生命变量时，变量是不可变的，

```rust
let x = 5;
x = 6; // 报错
```

当对 `x`再次赋值时会报错。

## let mut

可以在声明变量时添加`mut`关键字使变量可变，

```rust
let mut x = 5;
x = 6; // 不报错
```

## 隐藏

新声明的变量可以覆盖掉旧的同名变量，

```rust
fn main(){
    let x = 5;
    
    let x = x + 1;
    
    let x = x * 2；
}
```

隐藏机制不同于将一个变量声明为`mut`。重复使用`let`关键字创建出新的变量。实际上，上文中3个`x`是三个同名的不同变量。

所以我们可以在复用变量名称的同时改变它的类型，

```rust
let spaces = " ";
let spaces = spacse.len();
```

但是使用`mut`来模拟以上效果就会出错，

```rust
let mut spaces = " ";
spaces = spaces.len();
```

编译器会拒绝修改变量的类型，因为自始至终`spacces`都为一个变量，变量类型在声明时就已经确定。

# 常量

## const

可以使用`const`声明一个常量，而且显示的标注值的类型。例如：

```rust
const MAX_POINTS: u32 = 10_000;
```

> 在数值中添加下划线来提高可读性，例如：`100_000_000`

# 数据类型

Rust 有两种数据类型子集，

* 标量类型 scalar
* 复合类型 compound

Rust 是一门**静态类型语言**。大部分情况下编译器都自动推导出变量的类型。

如果编译器无法自动推导出变量的类型，需要手动的添加类型标注。

## 标量类型

标量类型是单个值类型的统称，

* 整数
* 浮点数
* 布尔值
* 字符

### 整数

* 8 bit: i8, u8
* 16 bit: i16, u16
* 32 bit: i32, u32
* arch: isize, usize

其中，`isize`与`usize`由程序运行的目标平台决定其长度。

除了 Byte，其余所有的字面量都可以使用类型后缀，比如：`57u8`，代表一个使用了`u8`类型的整数 57 。

其他表示方式举例，

* 98_222 十进制
* 0xff 十六进制
* 0o77 八进制
* 0b111_000 二进制
* b'A' 字节

Rust 对于整数字面量默认推导 `i32` 类型。

### 浮点

有两种基础的浮点数类型，

* f32
* f64

Rust 中默认将浮点数字面量的类型推导为 `f64` 。

### 数值运算

```rust
fn main(){
    let sum = 5 + 10;
    let difference = 95.5 - 4.3;
    let product = 4 * 30;
    let quotient = 56.7 / 32.2;
    let remainder = 43 % 5; // 取余
}
```

### 布尔

`true` 和 `false`，占据单个字节的空间大小。

### 字符类型

`char` 使用单引号指定，

```rust
let c = 'z';
let cat = '🐱';
```

Rust 中的`char`类型占 **4 字节**，是一个 Unicode 标量值。

## 复合类型

### 元组

元组每个元素的类型不需要是相同的，且在声明后无法改变元素的数量。

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
```

#### 解构

```rust
let tup = (500, 6.4, 1);

let (x, y, z) = tup;
```

`let (x, y, z) = tup;` 这种操作被称为元祖的解构。
