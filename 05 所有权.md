[TOC]

# 所有权规则

* Rust 中的每一个值都有对应的变量作为他的所有者。
* 在同一时间内，值有且仅有一个所有者。
* 当所有者离开自己的作用域时，它持有的值就会被释放掉。

# 变量作用域

作用域是一个对象在程序中有效的范围。

变量从声明的位置开始，直到当前作用域结束都是有效的。

```rust
{
    let s = "hello"; // 从此开始 s 变得可用
}// 离开作用域后，s 变得不可用
```

变量占有的内存，会在变量离开作用域后被释放。

> [!NOTE]
>
> Rust 在变量离开作用域时，会自动调用一个叫做 `drop` 的特殊函数。

# 变量和数据的交互方式

## 移动

### 值类型

```rust
let x = 5;
let y = x;
```

效果：

1. 将整数 5 绑定到变量 x 上；
2. 然后创建一个 x 值的拷贝，并将它绑定到 y 上。

### 引用变量

由于引用类型的数据结构与值类型不同，

> [!NOTE]
>
> 对值的引用存储在栈上，值存储在堆上。

所以其赋值时实际上只复制了引用，即：浅拷贝，这一特点与大多数面向对象的语言相同。

不同的是，Rust 规定：**在同一时间内，值有且仅有一个所有者**。所以在赋值时，Rust 发生了变量所有权的移动，例如，

```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
```

在上述代码中，`let s2 = s1;` 运行后，数据的所有权就由 `s1` 转移至 `s2` ，`s1` 不再持有数据的所有权，所以 `println!("{}, world!", s1);` 会发生出错误。

> [!IMPORTANT]
>
> **当一个变量离开当前作用域时，Rust 会自动调用它的 `drop` 函数，并将变量使用的堆内存回收。**
>
> 如果在同一时间内，值有多个所有者，当所有者同时离开作用域时，会发生**二次释放**，当所有者相继离开作用域时，会造成**悬空指针**。以上设计则避免了这些问题。
>
> 另外，这里隐含了一个设计原则：**Rust 永远不会自动地创建数据的深度拷贝**。

## 克隆

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

上述代码中，使用 `clone()` 函数对 `s1` 进行了深拷贝，`s1` 的所有权并未因此转移至 `s2` ，所以以上代码合法。

# Copy 与 Drop

Rust 提供了一个名为 `Copy` 的 trait，它可以用于整数这类完全存储在栈上的数据类型。

拥有 `Copy` trait 的类型，它的变量在赋值给其他变量后依旧保持可用性，不会发生所有权的移动。

与之相反，拥有 `Drop` trait 的类型，它的变量在赋值给其他变量后失去了可用性，发生了所有权的移动。

> [!IMPORTANT]
>
> 如果一个类型本身或这种类型的任意成员实现了 `Drop` trait，Rust 则不会允许实现 `Copy` trait。

拥有 `Copy` 的类型，

* 所有的整数类型
* 布尔类型
* 字符类型
* 所有的浮点类型
* 所有字段都拥有 `Copy` 的元组。