[TOC]

# 所有权规则

* Rust 中的每一个值都有对应的变量作为他的所有者。
* 在同一时间内，值有且仅有一个所有者。
* 当所有者离开自己的作用域时，它持有的值就会被释放掉。

# 变量作用域

作用域是一个对象在程序中有效的范围。

变量从声明的位置开始，直到当前作用域结束都是有效的。

```rust
{
    let s = "hello"; // 从此开始 s 变得可用
}// 离开作用域后，s 变得不可用
```

变量占有的内存，会在变量离开作用域后被释放。

> [!NOTE]
>
> Rust 在变量离开作用域时，会自动调用一个叫做 `drop` 的特殊函数。

# 变量和数据的交互方式

## 移动

### 值类型

```rust
let x = 5;
let y = x;
```

效果：

1. 将整数 5 绑定到变量 x 上；
2. 然后创建一个 x 值的拷贝，并将它绑定到 y 上。

### 引用变量

由于引用类型的数据结构与值类型不同，

> [!NOTE]
>
> 对值的引用存储在栈上，值存储在堆上。

所以其赋值时实际上只复制了引用，即：浅拷贝，这一特点与大多数面向对象的语言相同。

不同的是，Rust 规定：**在同一时间内，值有且仅有一个所有者**。所以在赋值时，Rust 发生了变量所有权的移动，例如，

```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
```

在上述代码中，`let s2 = s1;` 运行后，数据的所有权就由 `s1` 转移至 `s2` ，`s1` 不再持有数据的所有权，所以 `println!("{}, world!", s1);` 会发生出错误。

> [!IMPORTANT]
>
> **当一个变量离开当前作用域时，Rust 会自动调用它的 `drop` 函数，并将变量使用的堆内存回收。**
>
> 如果在同一时间内，值有多个所有者，当所有者同时离开作用域时，会发生**二次释放**，当所有者相继离开作用域时，会造成**悬空指针**。以上设计则避免了这些问题。
>
> 另外，这里隐含了一个设计原则：**Rust 永远不会自动地创建数据的深度拷贝**。

## 克隆

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

上述代码中，使用 `clone()` 函数对 `s1` 进行了深拷贝，`s1` 的所有权并未因此转移至 `s2` ，所以以上代码合法。

## Copy 与 Drop

Rust 提供了一个名为 `Copy` 的 trait，它可以用于整数这类完全存储在栈上的数据类型。

拥有 `Copy` trait 的类型，它的变量在赋值给其他变量后依旧保持可用性，不会发生所有权的移动。

与之相反，拥有 `Drop` trait 的类型，它的变量在赋值给其他变量后失去了可用性，发生了所有权的移动。

> [!IMPORTANT]
>
> 如果一个类型本身或这种类型的任意成员实现了 `Drop` trait，Rust 则不会允许实现 `Copy` trait。

拥有 `Copy` 的类型，

* 所有的整数类型
* 布尔类型
* 字符类型
* 所有的浮点类型
* 所有字段都拥有 `Copy` 的元组。

# 所有权与函数

## 参数值

将值传递给函数在语义上类似与对变量进行赋值。将变量传递给函数会发生移动或复制。

```rust
fn main(){
    let s = String::from("hello"); // 变量 s 进入作用域
    
    takes_ownership(s); // s 的值被转移进了函数，发生了移动，s 不再有效，
    // 之后如果尝试调用 s 将发生错误
    let x = 5;// x 进入作用域
    
    makes_copy(x);// x 类型为 u32，所以此处发生了赋值，没有发生移动，x 依旧有效
}// 离开作用域后，由于 s 不在有效，所以此处不会调用 s 的 drop 函数。

fn takes_ownership(some_string: String){// s 值的所有权转移至 some_string 上
    println!("{}", some_string);// some_string 拥有对值的所有权，这里不会发生错误
}// some_string 离开作用域，其值被回收
```

所以，

* 调用函数会发生所有权的移动或复制，由实参转移至形参。
* 在形参离开作用域后，值的所有权不会返还给之前的实参，会被回收掉。

## 返回值

函数在返回值的过程总也会发生所有权的转移。

> [!IMPORTANT]
>
> 所有权的转移总是遵循相同的模式：
>
> **将一个值赋值给另一个变量时就会转移所有权。当一个持有堆数据的变量，离开作用域时，它的数据就会被 `drop` 清理回收，除非这些数据的所有权移动到另一个变量上。**

# 引用

## 引用与借用

使用 `&` 可实现在不获取所有权的前提下使用值。

```rust
fn main(){
    let s1 = String::from("hello");
    
    let len = calculate_length(&s1);
    
    println!("The lenght of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

上述代码中，调用 `calculate_length` 函数时，使用了 `&s1` 作为参数，函数定义中，使用 `&String` 代替 `String`。

`&s1` 语法允许在**不转移所有权**的前提下，创建一个指向 `s1` 值的引用。

函数签名中的 `&` 用来表名参数 `s` 的类型是一个引用。

在 `s` 离开作用域时，由于 `s` 不持有对值的所有权，所以不会调用 `drop` 函数。

> [!NOTE]
>
> 这种通过引用传递参数给函数的方法也被称为**借用**。

> [!WARNING]
>
> 注意，与变量类似，引用也是默认不可变的，Rust 不允许我们去修改引用指向的值。

## 可变引用

将 `&` 变为 `&mut` ，即可将引用变为可变引用，可以修改引用指向的值。

> [!WARNING]
>
> 有两条规则需要注意，
>
> 1. **对于特定作用域中的特定数据来说，一次只能声明一个可变引用**。
>
> 这条规则避免了**数据竞争**。
>
> > [!TIP]
> >
> > 可以通过花括号来创建一个新的作用域范围，这就可以使我们创建多个可变引用。
>
> 2. **不能在拥有不可变引用的同时创建可变引用**

## 引用的规则

* 在任何一段给定的时间里，你要么只能拥有一个可变引用，要么只能拥有任意数量的不可变引用。
* 引用总是有效的。

# 切片

与引用一样，**切片**也是一种不持有所有权的数据类型。

切片允许我们引用集合中某一段连续的元素序列，而不是整个集合。

## 字符串切片

```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```

上述代码中，`hello` 与 `world` 就是两个持有字符串 `s` 某一连续部分的切片。

> [!NOTE]
>
> Rust 的范围语法 `..` 有个小小的语法糖，当你的索引值从 0 开始时，可以省略 `..` 之前的值，例如：`&s[..5]`；
>
> 同样的，如果你的索引值从最后一个元素结束时，可以忽略 `..` 之后的值，例如：`&s[6..]`；
>
> 甚至，可以同时省略首尾的两个值，来创建一个指向整个字符串所有字节的切片，例如：`&s[..]`；